import { describe, expect, it, vi } from "vitest";
import type { ConfigV3, InstantiatedConfig } from "./config-types";
import {
  convertV3ConfigToV4,
  createV3CompatibilityData,
} from "./config-conversion";

describe("V3 to V4 Config Conversion", () => {
  const mockSchemas: Record<string, any> = {
    public: {
      name: "public",
      tables: [],
      views: [],
      materializedViews: [],
      types: [],
    },
  };

  const baseInstantiatedConfig: InstantiatedConfig = {
    connection: "postgres://localhost/test",
    schemas: mockSchemas,
    typeMap: {},
    getMetadata: vi.fn(),
    getPropertyMetadata: vi.fn(),
    generateIdentifierType: vi.fn(),
    getRoutineMetadata: vi.fn(),
    propertySortFunction: vi.fn(),
    enumStyle: "enum",
    outputPath: "./models",
    preDeleteOutputFolder: false,
    resolveViews: true,
    fileExtension: ".ts",
  };

  describe("convertV3ConfigToV4", () => {
    it("should convert a minimal V3 config to V4", () => {
      const v3Config: ConfigV3 = {
        connection: "postgres://localhost/test",
      };

      const v4Config = convertV3ConfigToV4(
        v3Config,
        baseInstantiatedConfig,
        mockSchemas,
        { suppressDeprecationWarning: true },
      );

      expect(v4Config).toHaveProperty("typescriptConfig");
      expect(v4Config).toHaveProperty("generators");
      expect(v4Config.typescriptConfig.enumStyle).toBe("enum");
      expect(v4Config.generators).toHaveLength(1);
    });

    it("should map V3 enumStyle 'type' to V4 'literal'", () => {
      const v3Config: ConfigV3 = {
        connection: "postgres://localhost/test",
        enumStyle: "type",
      };

      const instantiatedConfig = {
        ...baseInstantiatedConfig,
        enumStyle: "type" as const,
      };

      const v4Config = convertV3ConfigToV4(
        v3Config,
        instantiatedConfig,
        mockSchemas,
        { suppressDeprecationWarning: true },
      );

      expect(v4Config.typescriptConfig.enumStyle).toBe("literal");
    });

    it("should map V3 enumStyle 'enum' to V4 'enum'", () => {
      const v3Config: ConfigV3 = {
        connection: "postgres://localhost/test",
        enumStyle: "enum",
      };

      const v4Config = convertV3ConfigToV4(
        v3Config,
        baseInstantiatedConfig,
        mockSchemas,
        { suppressDeprecationWarning: true },
      );

      expect(v4Config.typescriptConfig.enumStyle).toBe("enum");
    });

    it("should convert schemas to schemaNames", () => {
      const v3Config: ConfigV3 = {
        connection: "postgres://localhost/test",
        schemas: ["public", "custom"],
      };

      const v4Config = convertV3ConfigToV4(
        v3Config,
        baseInstantiatedConfig,
        mockSchemas,
        { suppressDeprecationWarning: true },
      );

      expect(v4Config.schemaNames).toEqual(["public", "custom"]);
    });

    it("should preserve other V3 config properties", () => {
      const v3Config: ConfigV3 = {
        connection: "postgres://localhost/test",
        outputPath: "./custom/path",
        preDeleteOutputFolder: true,
        resolveViews: false,
        tsModuleFormat: "esm",
      };

      const v4Config = convertV3ConfigToV4(
        v3Config,
        baseInstantiatedConfig,
        mockSchemas,
        { suppressDeprecationWarning: true },
      );

      expect(v4Config.outputPath).toBe("./custom/path");
      expect(v4Config.preDeleteOutputFolder).toBe(true);
      expect(v4Config.resolveViews).toBe(false);
      expect(v4Config.typescriptConfig.tsModuleFormat).toBe("esm");
    });

    it("should wrap pre-render hooks", () => {
      const mockPreRenderHook = vi.fn((output) => output);

      const v3Config: ConfigV3 = {
        connection: "postgres://localhost/test",
        preRenderHooks: [mockPreRenderHook],
      };

      const v4Config = convertV3ConfigToV4(
        v3Config,
        baseInstantiatedConfig,
        mockSchemas,
        { suppressDeprecationWarning: true },
      );

      // V3 pre-render hooks are moved to PgTsGenerator-specific hooks
      expect(v4Config.preRenderHooks).toBeUndefined();

      // Should have a PgTsGenerator with applyTaggedComments + user hook
      expect(v4Config.generators).toHaveLength(1);
      // We can't directly inspect the generator config, but we can verify it exists
    });

    it("should wrap post-render hooks", () => {
      const mockPostRenderHook = vi.fn((_path, lines) => lines);

      const v3Config: ConfigV3 = {
        connection: "postgres://localhost/test",
        postRenderHooks: [mockPostRenderHook],
      };

      const v4Config = convertV3ConfigToV4(
        v3Config,
        baseInstantiatedConfig,
        mockSchemas,
        { suppressDeprecationWarning: true },
      );

      expect(v4Config.postRenderHooks).toHaveLength(1);
    });

    it("should apply markAsGenerated by default if no post-render hooks provided", () => {
      const v3Config: ConfigV3 = {
        connection: "postgres://localhost/test",
        // No postRenderHooks specified
      };

      const v4Config = convertV3ConfigToV4(
        v3Config,
        baseInstantiatedConfig,
        mockSchemas,
        { suppressDeprecationWarning: true },
      );

      // Should have markAsGenerated by default
      expect(v4Config.postRenderHooks).toHaveLength(1);
    });

    it("should print deprecation warning by default", () => {
      const consoleWarnSpy = vi
        .spyOn(console, "warn")
        .mockImplementation(() => {});

      const v3Config: ConfigV3 = {
        connection: "postgres://localhost/test",
      };

      convertV3ConfigToV4(v3Config, baseInstantiatedConfig, mockSchemas);

      expect(consoleWarnSpy).toHaveBeenCalled();
      expect(consoleWarnSpy.mock.calls[0][0]).toContain("DEPRECATION WARNING");

      consoleWarnSpy.mockRestore();
    });

    it("should suppress deprecation warning when requested", () => {
      const consoleWarnSpy = vi
        .spyOn(console, "warn")
        .mockImplementation(() => {});

      const v3Config: ConfigV3 = {
        connection: "postgres://localhost/test",
      };

      convertV3ConfigToV4(v3Config, baseInstantiatedConfig, mockSchemas, {
        suppressDeprecationWarning: true,
      });

      expect(consoleWarnSpy).not.toHaveBeenCalled();

      consoleWarnSpy.mockRestore();
    });
  });

  describe("createV3CompatibilityData", () => {
    it("should extract wrapped metadata functions", () => {
      const getMetadataMock = vi.fn();
      const getPropertyMetadataMock = vi.fn();

      const v3Config: ConfigV3 = {
        connection: "postgres://localhost/test",
        getMetadata: getMetadataMock,
        getPropertyMetadata: getPropertyMetadataMock,
      };

      const compatData = createV3CompatibilityData(
        v3Config,
        baseInstantiatedConfig,
      );

      expect(compatData.wrappedMetadata.getMetadata).toBeDefined();
      expect(compatData.wrappedMetadata.getPropertyMetadata).toBeDefined();
    });

    it("should include propertySortFunction", () => {
      const sortFn = vi.fn();

      const v3Config: ConfigV3 = {
        connection: "postgres://localhost/test",
        propertySortFunction: sortFn,
      };

      const compatData = createV3CompatibilityData(
        v3Config,
        baseInstantiatedConfig,
      );

      expect(compatData.propertySortFunction).toBe(sortFn);
    });

    it("should include customTypeMap", () => {
      const typeMap = { "pg_catalog.text": "string" };

      const v3Config: ConfigV3 = {
        connection: "postgres://localhost/test",
        customTypeMap: typeMap,
      };

      const compatData = createV3CompatibilityData(
        v3Config,
        baseInstantiatedConfig,
      );

      expect(compatData.customTypeMap).toBe(typeMap);
    });
  });
});
